using UnityEngine;
using UnityEditor;
using Cinemachine;

//Generated by ChatGPT, operator: kikurage3859
//edited by frou01
public class ParallelPathGenerator : EditorWindow
{
    private CinemachineSmoothPath sourcePath;
    private int numberOfCopies = 1;
    private float offsetDistance = 2.25f;
    private bool includeBothSides = true;
    private bool flipLeftSidePaths = false;
    private bool flipRightSidePaths = true;

    [MenuItem("Tools/Cinemachine/Generate Parallel Paths")]
    public static void ShowWindow()
    {
        GetWindow<ParallelPathGenerator>("Parallel Path Generator");
    }

    private void OnGUI()
    {
        GUILayout.Label("Generate Parallel CinemachineSmoothPaths", EditorStyles.boldLabel);
        sourcePath = EditorGUILayout.ObjectField("Source Path", sourcePath, typeof(CinemachineSmoothPath), true) as CinemachineSmoothPath;
        numberOfCopies = EditorGUILayout.IntField("Number of Copies", numberOfCopies);
        offsetDistance = EditorGUILayout.FloatField("Offset Distance", offsetDistance);
        includeBothSides = EditorGUILayout.Toggle("Mirror Left & Right", includeBothSides);

        if (includeBothSides)
        {
            flipLeftSidePaths = EditorGUILayout.Toggle("Flip Left Side Paths", flipLeftSidePaths);
            flipRightSidePaths = EditorGUILayout.Toggle("Flip Right Side Paths", flipRightSidePaths);
        }
        else
        {
            flipRightSidePaths = EditorGUILayout.Toggle("Flip Right Side Paths", flipRightSidePaths);
        }

        if (GUILayout.Button("Generate"))
        {
            if (sourcePath == null)
            {
                EditorUtility.DisplayDialog("Error", "Please assign a CinemachineSmoothPath.", "OK");
                return;
            }

            GeneratePaths();
        }
    }

    private void GeneratePaths()
    {
        Vector3[] originalPoints = new Vector3[sourcePath.m_Waypoints.Length];
        for (int i = 0; i < originalPoints.Length; i++)
        {
            originalPoints[i] = sourcePath.transform.TransformPoint(sourcePath.m_Waypoints[i].position);
        }

        int total = includeBothSides ? numberOfCopies * 2 : numberOfCopies;

        for (int copyIndex = 1; copyIndex <= total; copyIndex++)
        {
            int sideIndex = Mathf.CeilToInt(copyIndex / 2f);
            int sign = includeBothSides
                ? ((copyIndex % 2 == 1 ? 1 : -1) * sideIndex) // 1, -1, 2, -2, ...
                : copyIndex;

            bool isLeft = includeBothSides && sign < 0;
            bool isRight = !isLeft;

            Vector3[] newPoints = new Vector3[originalPoints.Length];

            for (int i = 0; i < originalPoints.Length; i++)
            {
                Vector3 forward;
                if (i < originalPoints.Length - 1)
                    forward = (originalPoints[i + 1] - originalPoints[i]).normalized;
                else
                    forward = (originalPoints[i] - originalPoints[i - 1]).normalized;

                Vector3 normal = Vector3.Cross(Vector3.up, forward).normalized;
                newPoints[i] = originalPoints[i] + normal * offsetDistance * sign;
            }

            // フリップ条件をチェック
            bool doFlip = (isLeft && flipLeftSidePaths) || (isRight && flipRightSidePaths);
            if (doFlip)
            {
                System.Array.Reverse(newPoints);
            }

            GameObject newPathObj = new GameObject(sourcePath.name + "_Parallel_" + copyIndex);
            newPathObj.transform.position = Vector3.zero;
            var newPath = newPathObj.AddComponent<CinemachineSmoothPath>();
            newPath.m_Waypoints = new CinemachineSmoothPath.Waypoint[newPoints.Length];

            for (int i = 0; i < newPoints.Length; i++)
            {
                int srcIndex = doFlip ? newPoints.Length - 1 - i : i;
                newPath.m_Waypoints[i].position = newPath.transform.InverseTransformPoint(newPoints[i]);
                newPath.m_Waypoints[i].roll = sourcePath.m_Waypoints[srcIndex].roll * (doFlip ? -1 : 1);
            }

            newPath.m_Looped = sourcePath.m_Looped;
            

            Undo.RegisterCreatedObjectUndo(newPathObj, "Create Parallel Path");
        }
    }
}
